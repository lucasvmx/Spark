#
# Script para gerar um arquivo de instalação do inno setup compiler
# 
# Autor: Lucas Vieira de Jesus <lucas.engen.cc@gmail.com>
#

from argparse import ArgumentParser
import argparse
from sys import path
from urllib.request import urlopen


template='''; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "Spark"
#define MyAppVersion "$VERSAO"
#define MyAppPublisher "Lucas Vieira"
#define MyAppURL "https://github.com/lucas-engen/Spark"
#define MyAppExeName "$NOME_EXECUTAVEL"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{356A847D-6154-4D99-A673-87C958E3BDFD}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={pf}\{#MyAppName}
DisableProgramGroupPage=yes
LicenseFile=$CAMINHO_LICENSA
InfoBeforeFile=$CAMINHO_LICENSA
InfoAfterFile=$CAMINHO_LICENSA
OutputDir=$CAMINHO_OUTPUT_INSTALADOR
OutputBaseFilename=Spark-$VERSAO-$ARCH
SetupIconFile=$PASTA_IMAGENS\iconfinder__snowflake_1679761_ico.ico
Compression=lzma
SolidCompression=yes

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"
Name: "brazilianportuguese"; MessagesFile: "compiler:Languages\BrazilianPortuguese.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "$LOCAL_EXECUTAVEL"; DestDir: "{app}"; Flags: ignoreversion
Source: "$PASTA_EXECUTAVEL\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{commonprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{commondesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: shellexec postinstall skipifsilent
'''

try: 
    import argparse
    from urllib.parse import urlparse
    from http.client import HTTPResponse
except Exception as e:
    print(f"Erro ao importar: {e}")

# Nome do arquivo de saida
output_filename = "setup.iss"

def parse_command_line():
    """Analisa os argumentos da linha de comando

    Returns:
        Dict: Um dicionário contendo os argumentos analisados
    """
    ap = ArgumentParser("Spark")
    ap.add_argument("--license", required=True, help="Caminho do arquivo de licensa")
    ap.add_argument("--exename", required=False, help="Nome do programa", default="Spark")
    ap.add_argument("--exepath", required=True, help="Caminho do executável principal")
    ap.add_argument("--exefolder", required=True, help="Caminho da pasta aonde o executável está localizado")
    ap.add_argument("--release_type", required=False, 
        help="Tipo da nova release: NF para 'new feature', BF para 'bugfix', NM para 'new major verson' "
        "e N para nenhum dos anteriores", default="N")
    ap.add_argument("--output", required=True, help="Pasta aonde o instalador final será compilado")
    ap.add_argument("--arch", required=False, help="Arquitetura (x86 ou x64)")
    ap.add_argument("--images-dir", required=True, help="Pasta aonde estão localizados os arquivos de imagem do projeto")

    parsed = vars(ap.parse_args())
    return parsed
 
def get_next_version(release_type: str):
    """Obtém a próxima versão do programa

    Args:
        release_type (str): Tipo da release

    Returns:
        str: String contendo a versão
    """

    url = "https://github.com/lucas-engen/Spark/releases/latest"
    print(f"[info] Checking current release at {url} ...")
    response = urlopen(url)
    next_ver = response.url
    parse_result = urlparse(next_ver)
    import os
    ver = os.path.split(parse_result.path)[1][1:]
    splited_ver = ver.split(".")

    major = int(splited_ver[0])
    minor = int(splited_ver[1])
    patch = int(splited_ver[2])
    
    # Calcula o nome da próxima versão de acordo com o tipo da release
    if release_type == "NM":
        major = major + 1
        minor = 0
        patch = 0
    elif release_type == "NF":
        minor = minor + 1
        patch = 0
    elif release_type == "BF":
        patch = patch + 1
    else:
        return ver

    ver = f"v{major}.{minor}.{patch}"
    print(f"[info] Next version should be: {ver}")
    return ver

if __name__ == "__main__":

    args = parse_command_line()
    version = get_next_version(args["release_type"])

    print("[info] Generating install script ...")
    print(f"\n{args}\n")

    # Substitui a informação no arquivo de template
    template = template.replace("$VERSAO", version)
    template = template.replace("$NOME_EXECUTAVEL", args["exename"])
    template = template.replace("$CAMINHO_LICENSA", args["license"])
    template = template.replace("$CAMINHO_OUTPUT_INSTALADOR", args["output"])
    template = template.replace("$ARCH", args["arch"])
    template = template.replace("$PASTA_IMAGENS", args["images_dir"])
    template = template.replace("$LOCAL_EXECUTAVEL", args["exepath"])
    template = template.replace("$PASTA_EXECUTAVEL", args["exefolder"])
    
    with open(output_filename, "w") as f:
        f.write(template)

    print(f"[info] Generation completed. Output: {output_filename}")